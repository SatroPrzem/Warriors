import { ValidationError } from "../util/error";
import { v4 as uuid } from "uuid";
import { pool } from "../util/maria-db";
import { FieldPacket } from "mysql2";

type WarriorRecordResults = [WarriorEntity[], FieldPacket[]];

interface WarriorEntity {
  // generated by uuid:v4
  id?: string;
  // Name is always unique.
  readonly name: string;
  readonly power: number;
  readonly defence: number;
  readonly stamina: number;
  readonly agility: number;
  wins?: number;
}

export class WarriorRecord implements WarriorEntity {
  // generated by uuid:v4
  public id?: string;
  // Name is always unique.
  public readonly name: string;
  public readonly power: number;
  public readonly defence: number;
  public readonly stamina: number;
  public readonly agility: number;
  public wins?: number;

  constructor(obj: WarriorEntity) {
    const { id, name, power, defence, stamina, agility, wins } = obj;

    const stats = [power, defence, stamina, agility];

    const sum = [power, defence, stamina, agility].reduce((prev, curr) => {
      return prev + curr;
    }, 0);

    for (const stat of stats) {
      if (stat <= 0) {
        throw new ValidationError(
          "Co ty, co ty?!\nPojedyńcza statystyka nie może być mniejsza niż 1."
        );
      }
    }

    if (sum !== 10) {
      throw new ValidationError(
        `Umiesz liczyć? xD\nSuma wszystkich statystyk musi wynosić 10.\nObecnie jest to ${sum}`
      );
    }

    if (name.length < 3 || name.length > 50) {
      throw new ValidationError(
        `Niepoprawne imię. Długość imienia musi znajdować się z przedziału 4-49, aktualnie ma ${name.length} znaków`
      );
    }

    this.id = id ?? uuid();
    this.name = name;
    this.power = power;
    this.defence = defence;
    this.stamina = stamina;
    this.agility = agility;
    this.wins = wins ?? 0;
  }

  static async nameIsTaken(name: string): Promise<boolean> {
    const [results] = (await pool.execute(
      "SELECT * FROM `warriors` WHERE `name` = :name",
      {
        name: name,
      }
    )) as WarriorRecordResults;
    return results[0] !== undefined;
  }

  static async getOne(id: string): Promise<WarriorEntity | null> {
    const [results] = (await pool.execute(
      "SELECT * FROM `warriors` WHERE `id` = :id",
      {
        id: id,
      }
    )) as WarriorRecordResults;
    return results.length === 0 ? null : results[0];
  }

  static async listAll(): Promise<WarriorEntity[]> {
    const [results] = (await pool.execute(
      "SELECT * FROM `warriors` ORDER BY `wins` DESC"
    )) as WarriorRecordResults;
    return results.map((obj) => new WarriorRecord(obj));
  }

  static async listTop(topCount: number): Promise<WarriorEntity[]> {
    const [results] = (await pool.execute(
      "SELECT * FROM `warrior` ORDER BY `wins` DESC LIMIT :topCount",
      { topCount: topCount }
    )) as WarriorRecordResults;
    return results.map((obj) => new WarriorRecord(obj));
  }

  async insert(): Promise<string> {
    await pool.execute(
      "INSERT INTO `warriors`(`id`, `name`, `power`, `defence`, `stamina`, `agility`, `wins`) VALUES (:id, :name, :power, :defence, :stamina, :agility, :wins)",
      {
        id: this.id,
        name: this.name,
        power: this.power,
        defence: this.defence,
        stamina: this.stamina,
        agility: this.agility,
        wins: this.wins,
      }
    );
    return this.id;
  }

  async update(): Promise<void> {
    await pool.execute("UPDATE `warriors` SET `wins` = :wins "),
      {
        wins: this.wins + 1,
      };
  }
}
